<canvas width="800" height="600"></canvas>
<div class="botoes">
    <button id="PoligonoBTN">Novo Poligono</button>
    <button id="CorBTN">Selecionar Cor</button>
    <button id="DesenhaBTN">Desenhar Poligono</button>
</div>
<div class="quadroCores"></div>
<input type="color" id="colorPolBTN" value="#99c1f1">

<style>
    .quadroCores {
        width: '100px';
        height: '100px';
        background-color: lightblue;
    }

    .tela {
        position: absolute;
        left: '100px';
        top: '100px';
    }
    .botoes{
        display: flex;
        flex-direction: row;
        padding: 1vh;
    }
    button{
        width: 15%;
        height: 5%;
        margin: 0 0.5vh;
        font-size: 1.7vh;
        padding: 1vh;
        background-color: rgb(255, 166, 32);
        border-style: none;
        border-radius: 1vh;
        color: white;
    }
    button:hover{
        background-color: rgb(216, 140, 0);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/chroma-js@2.4.2/chroma.min.js"></script>
<script>
    tela = document.querySelector('canvas');
    var pincel = tela.getContext('2d');
    var cor = '#99c1f1';
    var rgb = [153,193,241]; 

    pincel.fillStyle = 'grey';
    pincel.fillRect(0, 0, 800, 600);

    // Botões
    // criar conteiner de botoes para alinhar com o quadro
    const PoligonoBTN = document.getElementById('PoligonoBTN');
    const ColorPol = document.getElementById('colorPolBTN');

    PoligonoBTN.addEventListener('click', function() {
        pincel.clearRect(0, 0, 800, 600);

        pincel.fillStyle = 'grey';
        pincel.fillRect(0, 0, 800, 600);
    });

    // Evento para capturar a cor do polígono
    ColorPol.addEventListener('input', (event) => {
        cor = event.target.value;
        console.log(cor)
        rgb = chroma(cor).rgb();
        console .log("cor RGB: ", rgb);
    });

    let pontos = [];
    //let cores = [];

    function desenhaCirculo(evento) {
        var x = evento.pageX - tela.offsetLeft;
        var y = evento.pageY - tela.offsetTop;

        pontos.push({x, y, rgb});
        //cores.push({rgb});

        pincel.fillStyle = cor;
        pincel.beginPath();
        pincel.arc(x, y, 5, 0, 2 * Math.PI);
        pincel.fill();
        console.log(`Ponto: (${x}, ${y})`);
    }

    function tamanhoPol(pontos) { // Função para calular a maior e menor coordenada de y do polígono
        let menor = pontos[0].y;
        let maior = pontos[0].y;

        for (const p of pontos) { // Todos os pontos presentes na lista
            if (p.y < menor) menor = p.y;
            if (p.y > maior) maior = p.y;
        }

        return {menor, maior}
    }

    tela.onclick = desenhaCirculo;
    
    const DesenhaBTN = document.getElementById('DesenhaBTN');
    DesenhaBTN.addEventListener('click', function() {
        if (pontos.length < 3) return;

        pincel.beginPath();
        pincel.moveTo(pontos[0].x, pontos[0].y);

        const {maior, menor} = tamanhoPol(pontos); // Chama a função tamanhoPol

        //console.log("Ponto com menor y:", menor);
        //console.log("Ponto com maior y:", maior);

        size = 10;

        for (let i = 1; i < pontos.length; i++) {

            pincel.lineTo(pontos[i].x, pontos[i].y);
        }
        
        pincel.lineTo(pontos[0].x, pontos[0].y);
        pincel.strokeStyle = 'black';
        pincel.lineWidth = 2;
        pincel.stroke();

        //let listaIntersecoes = []
        // Interpolação Incremental

        let listaScanline = []; // cada casa do vetor é corresponde a uma coordenada y, qual terá uma outra lista com os pontos incidentes a serem desenhado
        for (let i = menor; i < maior; i++){
            listaScanline[i] = [];
        }

        for (let i = 0; i < pontos.length; i++) {
            const p1 = pontos[i];
            const p2 = pontos[(i+1) % pontos.length]; // para garantir que não ultapasse o último ponto
            //console.log(p1, p2);

            if(p1.y == p2.y) continue; // se a aresta é horizontal (ignora)
            // nn era pra ser p1.x == p2.x ?

            let yMin = Math.min(p1.y, p2.y);  // coordenada y do primeiro ponto desenhado
            let yMax = Math.max(p1.y, p2.y);  // coordenada y do segundo ponto desenhado

            let x = 0;
            if(p1.y < p2.y){ // pegamos o menor x da aresta (onde começa a aresta)
                x = p1.x;
                r = p1.rgb[0];
                g = p1.rgb[1];
                b = p1.rgb[2];
            } else{
                x = p2.x;
                r = p2.rgb[0];
                g = p2.rgb[1];
                b = p2.rgb[2];
            }

            let deltaX = (p2.x - p1.x) / (p2.y - p1.y); // taxa de variação incremental e coeficiente angular do segmento de reta p1->p2
            let deltaRGB = [];
            deltaRGB[0] = (p2.rgb[0] - p1.rgb[0]) / (p2.y - p1.y);
            deltaRGB[1] = (p2.rgb[1] - p1.rgb[1]) / (p2.y - p1.y);
            deltaRGB[2] = (p2.rgb[2] - p1.rgb[2]) / (p2.y - p1.y);

            let k = 1;
            
            
            listaScanline[yMin].push({'x': x, 'rgb': [r, g, b]}); // salvando o x inicial (menor entre os 2 pontos)
            
            //let anteriorX = 0;
            //let anteriorRGB = [];
            for(let altura = yMin + 1; altura <= yMax-1; altura++, k++){  // for pra calcular as intersecções entre os 2 ponto, Xnew -> X+Tx
                //anteriorX = listaScanline[altura-1][0].x;
                //anteriorRGB = listaScanline[altura-1][0].rgb;
                //console.log(anteriorRGB);
                listaScanline[altura].push({'x': x + (deltaX * k), 'rgb' : [r + deltaRGB[0] * k, g + deltaRGB[1] * k, b + deltaRGB[2] * k]});
            }
            // MUDAR K
            
            for(let altura = yMin; altura <= yMax-1; altura++){ // log para conferir as inserções
                //console.log(altura);altura
                //console.log(...listaScanline[altura]);
            }
            
        };

        pincel.strokeStyle = cor;
        pincel.lineWidth = 1;


        // x1 e x2 sao os pontos de começo e fim da linha
        // return pontos = vetor com todos os pontos inteiros entre x1 e x2
        function intervalo(x1, x2) {
            let pontos = [];
            
            for(let i = 0; x1.x <= x2.x; x1.x++, i++){
                pontos[i] = Math.round(x1.x);
            }
            return pontos;
        }


        // x1 = ponto incial
        // x2 = ponto final
        // passo = número de pontos a gerar

        // Ordena a scanline
        for (let i = menor; i < maior; i++){ // pega todas as scanlines
            listaScanline[i].sort((a, b) => a.x - b.x); // ordena com base no x
            //console.log(...listaScanline[i]);
            for(let j = 0; j < listaScanline[i].length; j+=2){ // pega os 2 valores ou mais da scanline

                // os dois pontos x da scanline
                let x1 = listaScanline[i][j];
                let x2 = listaScanline[i][j+1];

                deltaX = x2.x - x1.x; // variação entre x2 e x1
                deltaR = (x2.rgb[0] - x1.rgb[0]) / deltaX; // variação de RED entre x2 e x1
                deltaG = (x2.rgb[1] - x1.rgb[1]) / deltaX; // variação de GREEN entre x2 e x1
                deltaB = (x2.rgb[2] - x1.rgb[2]) / deltaX; // variação de BLUE entre x2 e x1

                // RGB do primeiro ponto da scanline
                let r = x1.rgb[0];
                let g = x1.rgb[1];
                let b = x1.rgb[2];

                // usamos round para arrendondar as coordenadas
                for (let k = Math.round(x1.x); k <= Math.round(x2.x); k++) { // percorre pixel a pixel do primeiro ao segundo ponto
                    pincel.fillStyle = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
                    pincel.fillRect(k, i, 1, 1);
                    
                    // incrementa a variação de RGB para a próxima iteração
                    r += deltaR;
                    g += deltaG;
                    b += deltaB;
                }
            }
        }

        //pincel.strokeStyle = cor; // Pinta o polígono com a cor anteriormente selecionada
        //pincel.lineWidth = 1;

        pontos = [];

    });

</script>